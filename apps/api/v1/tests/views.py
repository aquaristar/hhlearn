from django.views.generic import Viewfrom rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework import authentication, permissionsfrom rest_framework import serializersfrom apps.dashboard.models import *from apps.api.v1.utils.views import *from apps.api.v1.utils.exceptions import *from apps.api.v1.utils.responses import *from apps.api.v1.utils.helpers import *from datetime import datetimefrom datetime import timedeltafrom apps.api.v1.tests.serializers import *import stringimport randomimport timeimport mathfrom django.conf import settingsfrom django.core.mail import send_mailfrom django.core.mail import EmailMessageimport base64#get Test Attemptsclass APITestAttempt(APIView):    def get(self, request, format=None):        #is_monthly_saftey = self.request.QUERY_PARAMS.get('isMonthlySafety', None)                is_monthly_saftey = self.request.QUERY_PARAMS.get('isMonthlySafety', None)        course_id = self.request.QUERY_PARAMS.get('courseID', None)        test_attempt_id = self.request.QUERY_PARAMS.get('testAttemptID', None)                assignment_id = self.request.QUERY_PARAMS.get('assignmentID', None)        # lets het the page number. On intro page we don't need page number so pageNumber won't be passed and it's set to 0        cur_question_number = self.request.QUERY_PARAMS.get('questionNumber', 0)                answer_id = self.request.QUERY_PARAMS.get('answerID', None)                arrow = self.request.QUERY_PARAMS.get('arrow', None)                user = request.user                if is_monthly_saftey is None or course_id is None or test_attempt_id is None or course_id is None:            response = response_missing_fields()            raise ExceptionMissingFields(detail=response)        # we are adding try here just in case if query fails then db call doesn't show error.        try:                        test_attempt = CoreTempTestAttempts.objects.get(id=test_attempt_id)            #save test attempt with new question number            if cur_question_number == 0 and test_attempt.current_question_number is not 0:                cur_question_number = int(test_attempt.current_question_number)                        #get questions list for this test attempts            questions = CoreTempQuestionAnswersAttempts.objects.filter(temp_test_attempt_id=test_attempt.id, passed=False).order_by('id')            total_questions_count = len(questions)                        #save prev questions data            if int(test_attempt.current_question_number) < int(total_questions_count):                cur_question = questions[int(test_attempt.current_question_number)]                #set answer_id for passed question                                    if answer_id is not None:                    cur_question.question_answer_id = int(answer_id)                    cur_question.attempt_time = datetime.now()                    cur_question.save();                elif arrow == 'next':                    response = response_missing_fields()                    raise ExceptionMissingFields(detail=response)                        if arrow == 'next':                cur_question_number = int(cur_question_number) + 1            elif arrow == 'prev':                cur_question_number = cur_question_number - 1                        #increase current questions            test_attempt.current_question_number = int(cur_question_number)                        test_attempt.save()                            if int(cur_question_number) >= int(total_questions_count) and test_attempt.test.type.id != 3:                                #set time test taken                cur_time = datetime.now()                diff_time = cur_time - test_attempt.start_time                test_attempt.seconds_taken = math.ceil(diff_time.total_seconds())                test_attempt.save()                                content = {  'testData': 'test_complete' }                            else:                             test = test_attempt.test                                course_serializer = CourseSerializer(test.course, context={'request': request, 'page_number': int(0)})                                #get current question id for this test                                #questions_list = test_attempt.questions.split(',')                            #cur_question_id = questions_list[test_attempt.current_question_number]                  if test_attempt.test.type.id != 3:                                      cur_question_id = questions[int(test_attempt.current_question_number)].question_id                else:                    cur_question_id = 0                test_serializer = TempTestAttemptSerializer(test_attempt, context={'request': request, 'cur_question_id': int(cur_question_id)})                user_profile_serializer = UserProfileSerializer(request.user.core_user_profile)                                content = { 'testData': test_serializer.data,                            'courseData': course_serializer.data,                            'userData': user_profile_serializer.data,                         #'utilData': {'state_cell_phone_laws': state_cell_phone_laws_serializer.data},                }                                except Exception as e:            if hasattr(e, 'detail'):                response = e.detail            else:                response = dict()                response['message'] = str(e.message)                response['status'] = 'error'            raise ExceptionDefault(detail=response)         #assignment_id = self.request.QUERY_PARAMS.get('assignmentID', None)        return Response(content)        def post(self, request, format=None):        test_id = self.request.DATA.get('test_id', None)        method = self.request.DATA.get('method', None)        if test_id is not None:            if method == "change":                #get test objects for this id                test = CoreTests.objects.get(id=test_id)                is_activate = self.request.DATA.get('is_active', None)                if is_activate is not None:                    test.is_active = is_activate                                test.save()                                content = {'status': 'success'}                return Response(content)            else:                content = {'status': 'success'}        else:                    content = {'status': 'fail',                       'message': 'Test id is not defined'}                return Response(content)            # This is main API class for Test Start. class APITestStart(APIView):    def get(self, request, format=None):        try:            # need to check if this course id belongs to user or not?            course_id = self.request.QUERY_PARAMS.get('courseID', None)            # is it normal course type or safety course? because we have different table for each one.            monthly_safety_course = self.request.QUERY_PARAMS.get('monthlySafetyCourse', None)                        #get assignment id            assignment_id = self.request.QUERY_PARAMS.get('assignmentID', None)            #get test by course id            test = CoreTests.objects.get(course_id=course_id)                        #get user            user = request.user                        #check if test_attempt already exist            try:                            test_attempts = CoreTestAttempts.objects.get(test_id=test.id, assignment_id=assignment_id, user_id=user.id, passed=True)                                            response = response_test_exist()                                            except CoreTestAttempts.DoesNotExist:                                test_attempts = CoreTestAttempts.objects.filter(test_id=test.id, assignment_id=assignment_id, user_id=user.id, passed=False).order_by('-start_time')                                can_test_resume = False                                #check the resume ability                if len(test_attempts) == 0 or test.type.id == 3:                    can_test_resume = True                else:                    delta_time = timedelta(hours=24)                    available_time = test_attempts[0].start_time + timedelta(seconds=test_attempts[0].seconds_taken) + delta_time                    if  available_time <= datetime.now():                        can_test_resume = True                    else:                        response = response_test_dealyed()                                                    if can_test_resume == True:                    try:                        if len(test_attempts) > 0:                            test_attempts[0].start_time = datetime.now()                            test_attempts[0].save()                        response = response_test_started()                        #remove all temp answers attempts and temp test attempts                        temp_test_attempt = CoreTempTestAttempts.objects.filter(test_id=test.id, assignment_id=assignment_id, user_id=user.id).order_by('start_time')                        if len(temp_test_attempt) == 0:                            #create temp test attempt                            test_attempt = CoreTempTestAttempts.objects.create(user_id = user.id,                                                                               test_id = test.id,                                                                               assignment_id = assignment_id,                                                                               ip_address = get_client_ip(request),                                                                                                                                                                                                                         current_question_number = 0,                                                                               current_test_attempt_number = 1)                        else:                            test_attempt =  temp_test_attempt[len(temp_test_attempt) - 1]                            test_attempt.start_time = datetime.now()                            test_attempt.save()                                                if test.type.id == 3:                            response['testAttemptID'] = test_attempt.id                                                elif test_attempt.current_test_attempt_number == 1:                            #remove all answers attempts                            CoreTempQuestionAnswersAttempts.objects.filter(temp_test_attempt_id=test_attempt.id).delete()                            test_attempt.start_time = datetime.now()                                                        test_attempt.current_question_number = 0                            test_attempt.save()                                                        # We need to get limited questions list from questions list of this test randomly                            # At first we need to add all of mandatory question for this test to questinos list                            # After that we pick up the rest questions                            # Each course has a pool of questions to pull from. The test must be random, have the ability to have mandatory questions,                             # and questions that only are pulled if they meet certain criteria, like living in a specific state or county,                             # or their organization is accredited by a specific organization.                                                        # step 1                             # get mandatory questions for everyone                                                        #get total questions count for this test                            total_questions_count = test.course.number_test_questions                            if test.type.id == 2:                                total_questions_count = 50                                                        #create test answers object for mandatory qustion                             if test.type.id == 2:                                questions = CoreQuestions.objects.filter(is_active=1, is_mandatory=1, is_competency=1)                            else:                                 questions = CoreQuestions.objects.filter(test_id=test.id, is_active=1, is_mandatory=1)                                                                                        i = 0                            for q in questions:                                                                if i < total_questions_count:                                    i = i + 1                                    CoreTempQuestionAnswersAttempts.objects.create(temp_test_attempt_id = test_attempt.id,                                                                               question_id = q.id)                                                                                            #i = len(questions)                                                        #step2                            #get mandatory questions for accreditation agency                                                        #get user profile                            profile = user.core_user_profile                                                                                    if profile.department_id is not None:                                                accreditation_agency = profile.department.accreditation_agency                                if accreditation_agency is None:                                    accreditation_agency = profile.location.accreditation_agency                                            else:                                                accreditation_agency = profile.location.accreditation_agency                                                        if accreditation_agency is not None:                                                                if test.type.id == 2:                                    questions = CoreQuestions.objects.filter(is_active=1, accredited_agency_id=accreditation_agency.id, accredited_is_mandatory=1, is_competency=1)                                else:                                    questions = CoreQuestions.objects.filter(test_id=test.id, is_active=1, accredited_agency_id=accreditation_agency.id, accredited_is_mandatory=1)                                                                for q in questions:                                    if i < total_questions_count:                                        i = i + 1                                        CoreTempQuestionAnswersAttempts.objects.create(temp_test_attempt_id = test_attempt.id,                                                                                   question_id = q.id)                                #i = i + len(questions)                                                                               #step3                            #get mandatory questions for state                            if test.type.id == 2:                                questions = CoreQuestions.objects.filter(is_active=1, state_id=profile.location.state_id, state_is_mandatory=1, is_competency=1)                            else:                                questions = CoreQuestions.objects.filter(test_id=test.id, is_active=1, state_id=profile.location.state_id, state_is_mandatory=1)                            for q in questions:                                if i < total_questions_count:                                    i = i + 1                                    CoreTempQuestionAnswersAttempts.objects.create(temp_test_attempt_id = test_attempt.id,                                                                                   question_id = q.id)                            #i = i + len(questions)                                                        #step4                            #get mandatory questions for county_fips                            zip_codes = UtilZipCodes.objects.filter(zip_code=profile.location.zip_code)                                                        county_fips = ''                            if len(zip_codes) > 0:                                county_fips = zip_codes[0].county_fips                                if test.type.id == 2:                                    questions = CoreQuestions.objects.filter(is_active=1, county_fips=county_fips, county_fips_mandatory=1, is_competency=1)                                else:                                    questions = CoreQuestions.objects.filter(test_id=test.id, is_active=1, county_fips=county_fips, county_fips_mandatory=1)                                for q in questions:                                    if i < total_questions_count:                                        i = i + 1                                        CoreTempQuestionAnswersAttempts.objects.create(temp_test_attempt_id = test_attempt.id,                                                                                       question_id = q.id)                                #i = i + len(questions)                                                        #step5                            #get random list of questions                                                         questions = []                            questions_list = []                                                        accreditation_agency_id = None                                                        if accreditation_agency is not None:                                accreditation_agency_id = accreditation_agency.id                                if test.type.id == 2:                                    questions = CoreQuestions.objects.filter(is_active=1, is_regular=1, accredited_agency_id=accreditation_agency.id, accredited_is_mandatory=0, is_competency=1)                                else:                                                                                                    questions = CoreQuestions.objects.filter(test_id=test.id, is_active=1, is_regular=1, accredited_agency_id=accreditation_agency.id, accredited_is_mandatory=0)                                                                                                                   for q in questions:                                    questions_list.append(q)                                                        if test.type.id == 2:                                questions = CoreQuestions.objects.filter(is_active=1, is_regular=1, state_id=profile.location.state_id, state_is_mandatory=0, is_competency=1)                            else:                                questions = CoreQuestions.objects.filter(test_id=test.id, is_active=1, is_regular=1, state_id=profile.location.state_id, state_is_mandatory=0)                            for q in questions:                                questions_list.append(q)                                                        if county_fips is not '':                                if test.type.id == 2:                                    questions = CoreQuestions.objects.filter(is_active=1, is_regular=1, county_fips=county_fips, county_fips_mandatory=0, is_competency=1)                                else:                                                                                                    questions = CoreQuestions.objects.filter(test_id=test.id, is_active=1, is_regular=1, county_fips=county_fips, county_fips_mandatory=0)                                for q in questions:                                    questions_list.append(q)                                                                                  if test.type.id == 2:                                questions = CoreQuestions.objects.filter(is_active=1, is_regular=1, is_mandatory=0, state_id=None, accredited_agency_id=None, county_fips=None, is_competency=1)                            else:                                        questions = CoreQuestions.objects.filter(test_id=test.id, is_active=1, is_regular=1, is_mandatory=0, state_id=None, accredited_agency_id=None, county_fips=None)                                                                                                       for q in questions:                                questions_list.append(q)                                                                                                    while i < total_questions_count and len(questions_list) > 0:                                i = i + 1                                item = random.choice(questions_list)                                CoreTempQuestionAnswersAttempts.objects.create(temp_test_attempt_id = test_attempt.id,                                                                               question_id = item.id)                                                                           questions_list.remove(item)                                                            #save total questions count                            test_attempt.total_questions_count = i                            test_attempt.save()                                                                    response = response_test_started()                                                    else:                                                        response = response_test_resumed()                                                                    response['testAttemptID'] = test_attempt.id                                        except Exception as e:                            if hasattr(e, 'detail'):                                        response = e.detail                                    else:                            response = dict()                            response['message'] = str(e.message)                            response['status'] = 'error'                                    raise ExceptionDefault(detail=response)                                except Exception as e:            if hasattr(e, 'detail'):                response = e.detail            else:                response = dict()                response['message'] = str(e.message)                response['status'] = 'error'            raise ExceptionDefault(detail=response)                content = {'response': response, }                return Response(content)        # This is main API class for Test End. class APITestEnd(APIView):    def get(self, request, format=None):        try:            # need to check if this course id belongs to user or not?            temp_test_attempt_id = self.request.QUERY_PARAMS.get('testAttemptID', None)                                                #get user            user = request.user                                    temp_test_attempt = CoreTempTestAttempts.objects.get(id=temp_test_attempt_id)                        temp_answers_attempts = CoreTempQuestionAnswersAttempts.objects.filter(temp_test_attempt_id = temp_test_attempt.id)                        passed_questions_count = 0                        #mandatory passed flag            mand_passed = True                        for answer in temp_answers_attempts:                if answer.question_answer.coreanswers.is_correct == 1:                                        #set this quesion answer is passed to true                    answer.passed = True                    answer.save()                    passed_questions_count = passed_questions_count + 1                elif mand_passed == True:                    if answer.question.is_mandatory == True or answer.question.accredited_is_mandatory == True \                        or answer.question.state_is_mandatory == True or answer.question.county_fips_mandatory == True:                        mand_passed = False                        #calculating test score            if temp_test_attempt.test.type.id == 3:                test_score = 0            else:                test_score = int(float(passed_questions_count) / int(temp_test_attempt.total_questions_count) * 100)                        #get user profile            profile = user.core_user_profile                        #calculate min passing score for this test            if temp_test_attempt.test.type_id == 4: #General Knowledge (100% Mandatory)                                min_passing_score = 100            elif temp_test_attempt.test.type_id == 1 or temp_test_attempt.test.type_id == 2:                #get min passing score                if profile.department_id is not None:                                    min_passing_score = profile.department.min_score_general_knowledge.score                              else:                                    min_passing_score = profile.location.min_score_general_knowledge.score            elif temp_test_attempt.test.type_id == 3:                min_passing_score = 0                        #check test is passed            if test_score >= min_passing_score:                #check mandatory question                if mand_passed == True:                                    passed = True                else:                    passed = False            else:                passed = False                        if passed == True or temp_test_attempt.current_test_attempt_number == 3:                                #create new Test Attempt object                test_attempt = CoreTestAttempts.objects.create(user_id = user.id,                                                               test_id = temp_test_attempt.test.id,                                                               assignment_id = temp_test_attempt.assignment_id,                                                               start_time = temp_test_attempt.start_time,                                                               ip_address = temp_test_attempt.ip_address,                                                                seconds_taken = temp_test_attempt.seconds_taken)                                for answer in temp_answers_attempts:                    CoreQuestionAnswersAttempts.objects.create( test_attempt_id = test_attempt.id,                                                                question_id = answer.question_id,                                                               question_answer_id = answer.question_answer_id,                                                               attempt_time = answer.attempt_time )                                test_attempt.passing_percentage = min_passing_score                test_attempt.test_grade = test_score                                #save test attempts passed or not                test_attempt.passed = passed                #save test attempt completed time                test_attempt.grade_date_time = convert_timezone(datetime.now(), request.user)#test_attempt.start_time + timedelta(seconds=test_attempt.seconds_taken)                                                if passed is True:                                        #remove course note for user                                        user_notes = CoreCoursesNote.objects.filter(user=request.user, courses_id=test_attempt.test.course.id)                                        if len(user_notes) is not 0:                        user_notes[0].date_last_saved = datetime.now()                        user_notes[0].date_passed_test = datetime.now()                        user_notes[0].date_to_purge = datetime.now()                        user_notes[0].save()                                            if test_attempt.test.type.id !=3:                        #caculate grade point                        gpa = (float)(UtilGradingScales.objects.get(percent=test_score).gpa)                        grade_point = gpa * (float)(test_attempt.test.course.hours)                                            test_attempt.grade_points = grade_point                                                #create certification code                        code1 = encryptnumber(test_attempt.id)                        code2 = encryptnumber(test_attempt.test_id)                            cert_code = code1+code2                         if len(cert_code) > 24:                            cert_code = cert_code[:24]                                                if len(cert_code) < 24:                            lst = [random.choice(string.ascii_letters + string.digits) for n in xrange(24-len(cert_code))]                            str = "".join(lst)                            cert_code = cert_code + lst                                                test_attempt.cert_id = cert_code                        test_attempt.cert_encrypted_id = base64.urlsafe_b64encode(cert_code)                                                            #set mark assignment as completed                    if test_attempt.test.course.monthly_safety_course_id == 1:                        assignment = CoreUserSafetyAssignments.objects.get(id=test_attempt.assignment_id)                    else:                        assignment = CoreUserAssignments.objects.get(id=test_attempt.assignment_id)                                        assignment.is_completed = True                    assignment.date_completed = datetime.now()                    assignment.save()                                        #check test completed by due date                    if assignment.due_date > datetime.now().date():                        test_attempt.completed_by_due_date = True                    else:                        test_attempt.completed_by_due_date = False                                                       test_attempt.save()                                #send email to manager if user did not pass test                if passed is False:                    msg = EmailMessage('Test failed',                       'User did not pass this test.', to=['example@gmail.com'])                    msg.send()                                    #remove all temp attempts                temp_answers_attempts.delete()                temp_test_attempt.delete()                                response = dict()                            response['status'] = 'test_completed'                response['testAttemptID'] = test_attempt.id                response['passedQuestionsCount'] = passed_questions_count                            response['totalQuestionsCount'] = test_attempt.test.course.number_test_questions                response['testScore'] = test_attempt.test_grade                        else:                                temp_test_attempt.current_test_attempt_number = temp_test_attempt.current_test_attempt_number + 1                temp_test_attempt.current_question_number = 0                temp_test_attempt.save()                response = dict()                            response['status'] = 'retaken_test'                #check the reason why user did not passed test(mandatory question incorrect? or testscore did not meet?)                                if test_score >= min_passing_score and mand_passed == False:                    response['mandTestFailed'] = True                else:                    response['mandTestFailed'] = False                                                                     except Exception as e:            if hasattr(e, 'detail'):                response = e.detail            else:                response = dict()                response['message'] = e.message                response['status'] = 'error'            raise ExceptionDefault(detail=response)                content = {'response': response, }        return Response(content)# This is main API class for Test End. class APITestResult(APIView):        def get(self, request, format=None):                # need to check if this course id belongs to user or not?        test_attempt_id = self.request.QUERY_PARAMS.get('testAttemptID', None)                            if test_attempt_id is None:            response = response_missing_fields()            raise ExceptionMissingFields(detail=response)        try:                        test_attempt = CoreTestAttempts.objects.get(id=test_attempt_id)                        answers_attempts = CoreQuestionAnswersAttempts.objects.filter(test_attempt_id = test_attempt.id)                        passed_questions_count = 0                        #mandatory passed flag            mand_passed = True                         #wrong questions topic            wrong_questions_topic = []                        for answer in answers_attempts:                if answer.question_answer.coreanswers.is_correct == 1:                    passed_questions_count = passed_questions_count + 1                else:                    if answer.question.topic not in wrong_questions_topic:                         wrong_questions_topic.append(answer.question.topic)            user = request.user                                    #get user profile            profile = user.core_user_profile                                    if profile.department_id is not None:                                min_passing_score = profile.department.min_score_general_knowledge                            else:                                min_passing_score = profile.location.min_score_general_knowledge                            course_serializer = CourseSerializer(test_attempt.test.course, context={'request': request, 'page_number': int(0)})                                    test_result = {'testAttemptID': test_attempt.id,                                                'totalQuestionsCount': test_attempt.test.course.number_test_questions,                        'testScore': test_attempt.test_grade,                        'testPassed': test_attempt.passed,                        'minScore': min_passing_score.score,                        'totalQuestionsCount': test_attempt.test.course.number_test_questions,                        'passedQuestionsCount': passed_questions_count,                        'secondsTaken': test_attempt.seconds_taken,                        'testType': test_attempt.test.type.id,                        'certificationUrl': test_attempt.cert_encrypted_id,                        'wrong_questions_topic': wrong_questions_topic,                                    }                        response = dict()                        response['status'] = 'success'            response['courseData'] = course_serializer.data            response['testResultData'] = test_result                              except Exception as e:            if hasattr(e, 'detail'):                response = e.detail            else:                response = dict()                response['message'] = str(e.message)                response['status'] = 'error'            raise ExceptionDefault(detail=response)                content = {'response': response, }        return Response(content)    #Get All testsclass APITestAll(APIView):        def get(self, request, format=None):        user = request.user        #get all tests        tests = CoreTests.objects.all()        tests_data = TestSerializer(tests).data                content = {'tests': tests_data}                return Response(content)#add new testsclass APITestAdd(APIView):        def get(self, request, format=None):        user=request.user                test_id = self.request.QUERY_PARAMS.get('test_id', None)        #get test data        organization = user.core_user_profile.core_organization.get(user_profiles__id=user.core_user_profile.id)        if test_id == None or int(test_id) == -1:                        test_data = None            questions_data = {}            #get courses for no test                        if organization.id == 1:                t_course_ids = CoreTests.objects.all().values_list('course_id', flat=True)                courses = CoreCourses.objects.all().exclude(id__in=t_course_ids).order_by('name')            else:                t_course_ids = CoreTests.objects.all().values_list('course_id', flat=True)                course_ids = CoreOrganizationsCustomCourses.objects.filter(organizations_id=organization.id).values_list('courses_id', flat=True)                courses = CoreCourses.objects.filter(id__in=course_ids).exclude(id__in=t_course_ids).order_by('name').values('id', 'number', 'name', 'number_test_questions')            courses_data = CourseMiniSerializer(courses).data                else:            test = CoreTests.objects.get(id=test_id)            test_data = TestSerializer(test).data            questions = CoreQuestions.objects.filter(test_id=test_id)#.values('id', 'type', 'text', 'is_active')            serializer_questions = QuestionsMiniSerializer(questions)            questions_data = serializer_questions.data            courses = CoreCourses.objects.filter(id=test.course.id)            courses_data = CourseMiniSerializer(courses).data                            #get test types        test_types = CoreTestTypes.objects.all()        test_types_data = TestTypeSerializer(test_types).data                #get question types        question_types = CoreQuestionTypes.objects.all()        serializer_question_types = QuestionTypesSerializer(question_types)        #get accreditation agencies data        accreditation_agencies = UtilRegAgencies.objects.filter(is_active=1, subclassification__id=1).order_by('name')        serializer_accreditation_agencies = AgenciesSerializer(accreditation_agencies)        #get state data        states = UtilUSAStates.objects.filter(sort=10)        serializer_states = StatesSerializer(states)                content = {'status': 'success',                   'test': test_data,                   'test_types': test_types_data,                   'courses': courses_data,                   'questions': questions_data,                   'question_types': serializer_question_types.data,                   'accreditation_agencies': serializer_accreditation_agencies.data,                   'states': serializer_states.data}                   #'county_fips': serializer_county_fips.data}        return Response(content)            def post(self, request, format=None):        user=request.user        test_id = self.request.DATA.get('test_id', None)        type = self.request.DATA.get('type', None)        course_id = self.request.DATA.get('course_id', None)        questions_count = self.request.DATA.get('questions_count', None)        is_active = self.request.DATA.get('is_active', None)                #if test_id is None then add test        if test_id is None:            if type is None or type == '' or course_id is None or course_id == '':                raise ExceptionDefault(detail=response)            course = CoreCourses.objects.get(number=course_id)            #create new test object            test = CoreTests.objects.create(course_id = course.id,                                             type_id = type,                                             is_active = is_active)            test.save()            if questions_count is not None:                course.number_test_questions = questions_count                course.save()        else:            test = CoreTests.objects.get(id=test_id)            if type is not None:                test.type_id = int(type)            if course_id is not None:                course = CoreCourses.objects.get(number=course_id)                test.course_id = course.id                if questions_count is not None:                                        course.number_test_questions = int(questions_count)                    course.save()            if is_active is not None:                test.is_active = is_active                        test.save()                content = {'status': 'success',                    'test_id': test.id }        return Response(content)#Question and answer management APIclass APITestQuestion(APIView):        #get question     def get(self, request, format=None):        user=request.user                question_id = self.request.QUERY_PARAMS.get('question_id', None)                if question_id is not None:            question = CoreQuestions.objects.get(id=question_id)            serializer_question = QuestionsSerializer(question)            question_data = serializer_question.data            '''                #get question types            question_types = CoreQuestionTypes.objects.all()            serializer_question_types = QuestionTypesSerializer(question_types)            #get accreditation agencies data            accreditation_agencies = UtilRegAgencies.objects.all()            serializer_accreditation_agencies = AgenciesSerializer(accreditation_agencies)            #get state data            states = UtilUSAStates.objects.all()            serializer_states = StatesSerializer(states)            '''                        #get county_fips data                        if question.state is not None:                county_fips = UtilZipCodes.objects.filter(state_abbr=question.state.abbreviation).values('county_name', 'state_abbr', 'county_fips').distinct()                serializer_county_fips = CountyFipsSerializer(county_fips).data            else:                serializer_county_fips = {}                                    content = {'status': 'success',                       'question': question_data,                                              'county_fips': serializer_county_fips}        else:            content = {'status': 'error',                       'message': 'Question ID is not defined!',}                    return Response(content)        #add or edit question    def post(self, request, format=None):        user=request.user        method = self.request.DATA.get('method', None)        question_data = self.request.DATA.get('question', None)                if method == 'add':            #create new question object             q = CoreQuestions.objects.create(test_id = question_data['test_id'],                                            type_id = question_data['type_id'],                                            text = question_data['text'],                                            topic = question_data['topic'],                                            is_regular = question_data['is_regular'],                                            is_mandatory = question_data['is_mandatory'],                                            is_competency = question_data['is_competency'],                                                                                            is_active = question_data['is_active'])            if question_data['is_accredited'] == True:                q.accredited_agency_id = question_data['accredited_agency_id']                q.accredited_is_mandatory = question_data['accredited_is_mandatory']            if question_data['is_state'] == True:                q.state_id = question_data['state_id']                q.state_is_mandatory = question_data['state_is_mandatory']            if question_data['is_county'] == True:                q.county_fips = question_data['county_fips']                q.county_fips_mandatory = question_data['county_fips_mandatory']            q.save()            #add question answers data            for answer in question_data['answers']:                ca = CoreAnswers.objects.create(text = answer['text'],                                                                                            why_this_choice = answer['why_this_choice'],                                                is_correct = answer['is_correct'],                                                is_active = answer['is_active'])                ca.save()                qa = CoreQuestionAnswers.objects.create(corequestions_id = q.id,                                                        coreanswers_id = ca.id)                qa.save()                        #get questions serializer data            serializer_data = QuestionsMiniSerializer(q)                                    content = {'status': 'success',                       'data': serializer_data.data }        elif method == 'remove':            q = CoreQuestions.objects.get(id = question_data['id'])            clear_answers = CoreQuestionAnswers.objects.filter(corequestions_id = q.id)            for clear_answer in clear_answers:                clear_answer.coreanswers.delete()            clear_answers.delete()            q.delete()            content = {'status': 'success',}        elif method == 'activate':            #get questions objects first            q = CoreQuestions.objects.get(id = question_data['id'])            is_active = self.request.DATA.get('is_active', None)            q.is_active = is_active            q.save()            content = {'status': 'success',}        elif method == 'change':                        #get questions objects first            q = CoreQuestions.objects.get(id = question_data['id'])            #q.test_id = question_data['test_id'];            q.type_id = question_data['type_id'];            q.text = question_data['text'];            q.topic = question_data['topic'];            q.is_regular = question_data['is_regular'];            q.is_mandatory = question_data['is_mandatory'];            q.is_competency = question_data['is_competency'];                                                            q.is_active = question_data['is_active'];                        if question_data['is_accredited'] == True:                q.accredited_agency_id = question_data['accredited_agency_id']                q.accredited_is_mandatory = question_data['accredited_is_mandatory']            else:                q.accredited_agency_id = None                q.accredited_is_mandatory = False            if question_data['is_state'] == True:                q.state_id = question_data['state_id']                q.state_is_mandatory = question_data['state_is_mandatory']                                if question_data['is_county'] == True:                    q.county_fips = question_data['county_fips']                    q.county_fips_mandatory = question_data['county_fips_mandatory']                else:                    q.county_fips = None                    q.county_fips_mandatory = False            else:                q.state_id = None                q.state_is_mandatory = False                q.county_fips = None                q.county_fips_mandatory = False                        q.save()                        #add question answers data            answer_ids = []            for answer in question_data['answers']:                #if already exist answer object then save object else create new answers object                if 'id' in answer:                                         ca = CoreAnswers.objects.get(id = answer['id'])                    ca.text = answer['text']                    ca.why_this_choice = answer['why_this_choice'];                    ca.is_correct = answer['is_correct'];                    if 'is_active' in answer:                        ca.is_active = answer['is_active'];                                        ca.save()                                    else:                    ca = CoreAnswers.objects.create(text = answer['text'],                                                                                                why_this_choice = answer['why_this_choice'],                                                    is_correct = answer['is_correct'],                                                    is_active = answer['is_active'])                    ca.save()                    qa = CoreQuestionAnswers.objects.create(corequestions_id = q.id,                                                            coreanswers_id = ca.id)                    qa.save()                    answer['id'] = ca.id                                    answer_ids.append(answer['id'])                                            #clear unused answers for question            clear_answers = CoreQuestionAnswers.objects.filter(corequestions_id = q.id).exclude(coreanswers_id__in=answer_ids)            for clear_answer in clear_answers:                clear_answer.coreanswers.delete()            clear_answers.delete()                        #get questions serializer data            #serializer_data = QuestionsMiniSerializer({'id':q.id, 'type':q.type_id, 'text':q.text, 'is_active':q.is_active}).data            serializer_data = QuestionsMiniSerializer(q).data                            content = {'status': 'success',                       'data': serializer_data}        else:            content = {'status': 'fail'}                    return Response(content)class APICountyFips(APIView):        #get question     def get(self, request, format=None):        state = self.request.QUERY_PARAMS.get('state', None)        if state is not None:            county_fips = UtilZipCodes.objects.filter(state_abbr=state).order_by('county_name').values('county_name', 'state_abbr', 'county_fips').distinct()            serializer_county_fips = CountyFipsSerializer(county_fips).data        else:            serializer_county_fips = {}        content = {'status': 'success',                   'county_fips': serializer_county_fips}        return Response(content)